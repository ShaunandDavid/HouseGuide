Got it—your issue is pure semantic routing. Here’s a drop-in, HIPAA-forward fix that upgrades your weekly reports from keyword dumps to meaningful, sectioned narratives with JSON-precise categorization + safe fallbacks. Copy/paste this as-is.

src/ai/generateWeeklyReport.ts (drop-in, production-ready)
// src/ai/generateWeeklyReport.ts
import OpenAI from "openai";
import z from "zod";

/**
 * HouseGuide Semantic Report Orchestrator
 * - Classifies entries into 5 sections via LLM JSON schema
 * - HIPAA-forward: redacts obvious PII before model call
 * - Deterministic fallback (rules) if LLM unavailable
 * - Returns polished Markdown report + structured JSON
 *
 * INPUT SHAPE expected by orchestrator (already matches your data fetch):
 * type Entry = {
 *   id: string;
 *   type: "goal"|"chore"|"meeting"|"incident"|"note";
 *   text: string;              // human text (goal/incident/note/etc.)
 *   createdAt: string;         // ISO
 *   tags?: string[];           // optional
 * };
 */

export type Entry = {
  id: string;
  type: "goal" | "chore" | "meeting" | "incident" | "note";
  text: string;
  createdAt: string;
  tags?: string[];
};

const MODEL = process.env.OPENAI_MODEL ?? "gpt-4o-mini"; // use "gpt-5" if enabled in your env
const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

/** ---------------- HIPAA-Forward utilities ---------------- **/

const REDACTION_REGEXES: Array<[RegExp, string]> = [
  // phones, emails, addresses (basic), names after labels
  [/\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g, "[PHONE]"],
  [/[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}/gi, "[EMAIL]"],
  [/\b\d{1,5}\s+[A-Za-z0-9.\-]+\s+(Street|St|Avenue|Ave|Road|Rd|Lane|Ln|Drive|Dr)\b/gi, "[ADDRESS]"],
  // label-based name captures (basic)
  /\b(Sponsor|Therapist|Doctor|Case\s*Manager)\s*:\s*([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)/g,
].map((r) => (Array.isArray(r) ? r : [r as unknown as RegExp, "[REDACTED_NAME]"])) as Array<[RegExp, string]>;

function redactPII(text: string): string {
  let out = text;
  for (const [rx, repl] of REDACTION_REGEXES) out = out.replace(rx, repl);
  return out;
}

function redactEntries(entries: Entry[]): Entry[] {
  return entries.map((e) => ({ ...e, text: redactPII(e.text) }));
}

/** ---------------- Section taxonomy ---------------- **/

const SectionId = z.enum([
  "SponsorMentor",
  "WorkSchool",
  "ChoresCompliance",
  "DemeanorParticipation",
  "ProfessionalHelpAppointments",
]);

const ClassifiedItem = z.object({
  id: z.string(),
  sourceType: z.enum(["goal", "chore", "meeting", "incident", "note"]),
  text: z.string(),
  reason: z.string(), // brief why it belongs here
  confidence: z.number().min(0).max(1),
  date: z.string().optional(),
  tags: z.array(z.string()).optional(),
});

const SectionBucket = z.object({
  items: z.array(ClassifiedItem),
  summary: z.string(), // concise narrative for the section
});

const ClassificationSchema = z.object({
  sections: z.object({
    SponsorMentor: SectionBucket,
    WorkSchool: SectionBucket,
    ChoresCompliance: SectionBucket,
    DemeanorParticipation: SectionBucket,
    ProfessionalHelpAppointments: SectionBucket,
  }),
  uncategorized: z.array(z.string()), // entry ids we couldn't confidently place
  overallSummary: z.string(),
});

export type Classification = z.infer<typeof ClassificationSchema>;

/** ---------------- Deterministic keyword fallback (last resort) ---------------- **/

const RULES: Record<z.infer<typeof SectionId>, RegExp[]> = {
  SponsorMentor: [
    /\b(aa|na|sponsor|mentor|meeting|12[-\s]?step|home\s*group)\b/i,
  ],
  WorkSchool: [
    /\b(job|work|shift|hire|resume|interview|clocked|school|class|credits|ged|college|study)\b/i,
  ],
  ChoresCompliance: [
    /\b(chore|dish|trash|laundry|clean|inspection|curfew|compliance|rule|assignment|duty)\b/i,
  ],
  DemeanorParticipation: [
    /\b(mood|agitated|anxious|argument|conflict|helpful|engaged|participation|demeanor|behavior|supportive)\b/i,
  ],
  ProfessionalHelpAppointments: [
    /\b(therap(y|ist)|counsel|doctor|psychiatr|medication|clinic|appointment|checkup|treatment|group\s*therapy)\b/i,
  ],
};

function ruleRoute(entry: Entry): z.infer<typeof SectionId> | null {
  for (const [section, tests] of Object.entries(RULES) as [z.infer<typeof SectionId>, RegExp[]][]) {
    if (tests.some((rx) => rx.test(entry.text))) return section;
  }
  return null;
}

/** ---------------- LLM classification ---------------- **/

async function classifyWithLLM(entries: Entry[]): Promise<Classification> {
  const schema = {
    name: "HouseGuideClassification",
    schema: ClassificationSchema.toJSON(), // Zod to JSON schema
    strict: true,
  };

  const system = [
    "You are HouseGuide's clinical report classifier.",
    "Classify each entry into EXACTLY one of these sections:",
    "1) SponsorMentor, 2) WorkSchool, 3) ChoresCompliance, 4) DemeanorParticipation, 5) ProfessionalHelpAppointments.",
    "Use SEMANTIC meaning, not keywords.",
    "If unsure, leave it out and include its id in uncategorized.",
    "Summaries must read like professional residential care notes.",
    "Keep PHI minimal (respect redactions already present).",
  ].join(" ");

  const examples = [
    {
      id: "ex1",
      type: "goal",
      text: "Attend AA meetings daily and check in with sponsor every evening.",
      expected: "SponsorMentor",
    },
    {
      id: "ex2",
      type: "note",
      text: "Resident reported therapy appointment completed today; next session next Friday.",
      expected: "ProfessionalHelpAppointments",
    },
    {
      id: "ex3",
      type: "incident",
      text: "Seemed agitated during dinner, raised voice at a peer, later apologized.",
      expected: "DemeanorParticipation",
    },
    {
      id: "ex4",
      type: "chore",
      text: "Completed kitchen duties, passed room inspection; curfew met.",
      expected: "ChoresCompliance",
    },
    {
      id: "ex5",
      type: "note",
      text: "Dropped off applications and interviewed at a warehouse.",
      expected: "WorkSchool",
    },
  ];

  const payload = {
    model: MODEL,
    temperature: 0.1,
    response_format: { type: "json_schema", json_schema: schema },
    input: [
      {
        role: "system",
        content: system,
      },
      {
        role: "user",
        content: [
          "Here are examples of correct categorization (for context only):",
          JSON.stringify(examples, null, 2),
          "Now classify the following entries. Respond ONLY with the JSON per the schema.",
          JSON.stringify(entries, null, 2),
        ].join("\n"),
      },
    ],
  } as const;

  const res = await client.responses.create(payload);
  const raw = res.output_text ?? (res as any).output[0]?.content[0]?.text ?? "";
  const parsed = ClassificationSchema.safeParse(JSON.parse(raw));
  if (!parsed.success) {
    throw new Error("LLM returned invalid JSON classification");
  }
  return parsed.data;
}

/** ---------------- Public Orchestrator ---------------- **/

export async function generateWeeklyReport(
  residentId: string,
  weekIsoRange: { start: string; end: string },
  entries: Entry[],
) {
  const sanitized = redactEntries(entries);

  // Try LLM first
  let classification: Classification | null = null;
  try {
    classification = await classifyWithLLM(sanitized);
  } catch (e) {
    // Fallback to deterministic rules
    const buckets: Record<z.infer<typeof SectionId>, z.infer<typeof SectionBucket>["items"]> = {
      SponsorMentor: [],
      WorkSchool: [],
      ChoresCompliance: [],
      DemeanorParticipation: [],
      ProfessionalHelpAppointments: [],
    };
    const uncategorized: string[] = [];

    for (const e of sanitized) {
      const where = ruleRoute(e);
      if (where) {
        buckets[where].push({
          id: e.id,
          sourceType: e.type,
          text: e.text,
          reason: "Rule-based fallback",
          confidence: 0.55,
          date: e.createdAt,
          tags: e.tags,
        });
      } else {
        uncategorized.push(e.id);
      }
    }

    function summarize(items: typeof buckets.SponsorMentor) {
      if (!items.length) return "No updates recorded in this category for the period.";
      const count = items.length;
      const types = [...new Set(items.map((i) => i.sourceType))].join(", ");
      return `Recorded ${count} item(s) (${types}). Key notes reflect typical activity and compliance for this week.`;
    }

    classification = {
      sections: {
        SponsorMentor: { items: buckets.SponsorMentor, summary: summarize(buckets.SponsorMentor) },
        WorkSchool: { items: buckets.WorkSchool, summary: summarize(buckets.WorkSchool) },
        ChoresCompliance: { items: buckets.ChoresCompliance, summary: summarize(buckets.ChoresCompliance) },
        DemeanorParticipation: { items: buckets.DemeanorParticipation, summary: summarize(buckets.DemeanorParticipation) },
        ProfessionalHelpAppointments: { items: buckets.ProfessionalHelpAppointments, summary: summarize(buckets.ProfessionalHelpAppointments) },
      },
      uncategorized,
      overallSummary:
        "Automated rule-based fallback enabled due to AI unavailability. Entries routed by deterministic heuristics.",
    };
  }

  // Compose a clean, court/insurer-friendly Markdown
  const md = buildMarkdownReport(weekIsoRange, classification);

  return {
    residentId,
    week: weekIsoRange,
    classification,
    markdown: md,
  };
}

/** ---------------- Markdown composer ---------------- **/

function sec(title: string, s: z.infer<typeof SectionBucket>) {
  const bullets =
    s.items.length === 0
      ? "- No updates this week."
      : s.items.map((i) => `- (${i.sourceType}) ${trimSentence(i.text)} *(conf: ${i.confidence.toFixed(2)})*`).join("\n");
  return `### ${title}\n${s.summary}\n\n${bullets}\n`;
}

function trimSentence(t: string, max = 240) {
  const cleaned = t.replace(/\s+/g, " ").trim();
  return cleaned.length > max ? cleaned.slice(0, max - 1) + "…" : cleaned;
}

function buildMarkdownReport(
  range: { start: string; end: string },
  c: Classification,
) {
  return [
    `# Weekly Resident Report`,
    `**Period:** ${range.start} → ${range.end}`,
    ``,
    `## Summary`,
    c.overallSummary,
    ``,
    sec("Sponsor / Mentor", c.sections.SponsorMentor),
    sec("Work / School", c.sections.WorkSchool),
    sec("Chores / Compliance", c.sections.ChoresCompliance),
    sec("Demeanor / Participation", c.sections.DemeanorParticipation),
    sec("Professional Help / Appointments", c.sections.ProfessionalHelpAppointments),
    ``,
    c.uncategorized.length
      ? `> Uncategorized entries (review recommended): ${c.uncategorized.join(", ")}`
      : `> All entries categorized.`,
  ].join("\n");
}